Hi,

This text document will contain all of the notes that I write
while reading through 'The Rust Programming Language'. I'll 
split em up by chapter. The rest of the documents in this repo
will be code snippets and projects from the book. Each chapter 
will have it's own directory and that'll contain all of the code
from that chapter. Okay? Okay.

---------
Chapter 1
---------

1.2:
Rust files always have the .rs extension
To compile a rust file use the command rustc. For example...

$ rustc main.rs

Then you run just like a compiled c program

$ ./main
$ Hello, world!

Like in many programming language, main is always the first code ..
that runs in a Rust programs. There are no parameters, but if there ..
were they would reside inside the parens

Like C and others, function bodies are wrapped in curlies. It's ..
good style to put the first curly on the same line as the function ..
declaration

You can use the rustfmt tool to automatically format to Rust's ..
weirdo specifications. [I've installed a vim package for Rust 
that allows this to be done as a command. Simply type :"RustFmt"]

println! calls a Rust macro. If it called a function instead we would ..
omit the ! at the end of println. This is discussed more in chapter 19

"Hello, world!" is a string and we end expressions with a semicolon

Before running a Rust program we have to compile it with Rust's ..
editor rustc while passing the name of the source file. Dynamic ..
languages like Python, Ruby, and JavaScript don't do this. 

Rust is an ahead-of-time compiled language, meaning I can compile ..
a program and give the executable to someone else and they ..
can run it on their machine without having Rust installed

Compiling with rustc is fine for small/simple programs, but as the ..
project grows, we'll want to be able to manage all of the options ..
and make it easier to share code. Rust's Cargo tool will help write ..
real-world Rust programs

1.3

Cargo is Rust's build system and package manager. Cargo handles
a lot of stuff for us including ...
1. Building the code
2. Downloading the libraries our code needs
3. Building those libraries (called dependencies)

The vast majority of Rust projects use Cargo

To create a new project using Cargo you type the following into 
the terminal ...

$ cargo new <project_name>

This command does a few things
1. It creates a new directory named project_name
2. It generates two files and a directory
    i. A toml file used for configuration of the project
    ii. A src directory beneath project_name
    iii. Inside here lies a hello_world starter file
3. It initializes a git repo (unless you're already in one)

For the toml file there are a few things to note
1. The first line [package] is a section heading that indicates 
that the following statements are configuring a package. As the
program grows, so too does the number of headings.

The next lines of information detail the information that Cargo 
needs to compile the program. The name, version, who wrote it, and 
edition of Rust to use. 

The last line is a section for the dependencies. In Rust, packages
of code are known as crates. You'll list these here when we need them

Cargo expects the source files for the program to exist within
the src directory. The top-level project directory is just for
README files, license information, configuration files, and 
other things not strictly related to the code. 

"There's a place for everything, and everything is in its place"

The Cargo new command doesn't do anything else special. If you
didn't use it, you can just put the main.rs into a src directory
and create a Cargo.toml file and no one will know ;)

Building and running a cargo project is slightly different than 
before. From the project directory you build the project by typing ...

$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
   Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs

This command also does multiple things
1. It creates an executable file in a new directory
    i. This is the target/debug directory
    ii. To run from wherever run ./target/debug/<project_name>
2. A new file called the Cargo.lock file is created
    i. This file keeps track of the exact versions of dependencies
    ii. You'll basically never manually edit this file

We can also use the following command to build and run the code

$ cargo run

This command builds and runs the code. If there's already an
executable, then it simply runs the executable. You can also
run the following command

$ cargo check

This command checks the code to make sure that it compiles
but doesn't create an executable. This is good because generally,
cargo check is faster than cargo build. You can continually check 
your work to make sure everything is compiling, then build when
you're ready to test. 

To recap ...
1. You can build a project with cargo build or cargo check
2. We can build and run using cargo run
3. The result is always saved in the target/debug directory

When the project is ready for release there is a special flag 
we can use to signify this ...

$ cargo build --release

This builds with optimizations and creates the executable in a new
directory: /target/release

These optimizations will make the executable run faster, but ultimately
increase the compile time. If you're benchmarking the speed or
handing the result to a user use the --release flag, else if you're
building and testing the code, don't bother

Cargo is a Rust convention. All substantial projects will use it.
To work on an existing Rust project, use the following commands ...

$ git clone someurl.com/someproject
$ cd someproject
$ cargo build

CHAPTER TAKEAWAYS:
- Installing the latest version of Rust
- Update to the newest Rust version
- Open locally installed documentation
- Write and run a Hello, world! program using rustc
- Create and run a project using Cargo

---------
Chapter 2
---------

